import { D as DEFAULT_PLACEHOLDER_SIZE, c as createPngDataUri$1 } from './shared/core.691dd044.mjs';
import { t as toElementArray, i as isCrawler, a as isLazyLoadingSupported, d as debounce } from './shared/core.ae5b1847.mjs';
export { c as base64ToBytes, g as getScaledDimensions, b as isSSR } from './shared/core.ae5b1847.mjs';
import { createPngDataUri } from './thumbhash.mjs';
import 'fast-blurhash';
import 'thumbhash';

function lazyLoad(selectorsOrElements = 'img[loading="lazy"]', {
  hash = true,
  hashType = "blurhash",
  placeholderSize = DEFAULT_PLACEHOLDER_SIZE,
  updateSizesOnResize = false,
  onImageLoad
} = {}) {
  const cleanupFns = /* @__PURE__ */ new Set();
  for (const image of toElementArray(selectorsOrElements)) {
    cleanupFns.add(
      updateSizesAttribute(image, updateSizesOnResize)
    );
    if (image.parentElement?.tagName.toLowerCase() === "picture") {
      [...image.parentElement.getElementsByTagName("source")].forEach(
        (sourceTag) => updateSizesAttribute(sourceTag)
      );
    }
    if (hash) {
      const placeholder = createPlaceholderFromHash({
        image,
        hash: typeof hash === "string" ? hash : void 0,
        hashType,
        size: placeholderSize
      });
      if (placeholder)
        image.src = placeholder;
    }
    if (!image.dataset.src && !image.dataset.srcset) {
      console.error("[unlazy] Missing `data-src` or `data-srcset` attribute", image);
      continue;
    }
    if (isCrawler || !isLazyLoadingSupported) {
      updatePictureSources(image);
      updateImageSrcset(image);
      updateImageSrc(image);
      continue;
    }
    if (image.complete && image.naturalWidth > 0) {
      loadImage(image, onImageLoad);
      continue;
    }
    const loadHandler = () => loadImage(image, onImageLoad);
    image.addEventListener("load", loadHandler, { once: true });
    cleanupFns.add(
      () => image.removeEventListener("load", loadHandler)
    );
  }
  return () => {
    for (const fn of cleanupFns)
      fn();
    cleanupFns.clear();
  };
}
function autoSizes(selectorsOrElements = 'img[data-sizes="auto"], source[data-sizes="auto"]') {
  for (const image of toElementArray(selectorsOrElements))
    updateSizesAttribute(image);
}
function loadImage(image, onImageLoad) {
  const imageLoader = new Image();
  const { srcset, src, sizes } = image.dataset;
  if (srcset)
    imageLoader.srcset = srcset;
  if (src)
    imageLoader.src = src;
  if (sizes)
    imageLoader.sizes = sizes;
  imageLoader.addEventListener("load", () => {
    updatePictureSources(image);
    updateImageSrcset(image);
    updateImageSrc(image);
    onImageLoad?.(image);
  });
}
function createPlaceholderFromHash({
  /** If given, the hash will be extracted from the image's `data-blurhash` or `data-thumbhash` attribute and ratio will be calculated from the image's actual dimensions */
  image,
  hash,
  hashType = "blurhash",
  /** @default 32 */
  size = DEFAULT_PLACEHOLDER_SIZE,
  /** Will be calculated from the image's actual dimensions if not provided and image is given */
  ratio
} = {}) {
  if (!hash && image) {
    const { blurhash, thumbhash } = image.dataset;
    hash = thumbhash || blurhash;
    hashType = thumbhash ? "thumbhash" : "blurhash";
  }
  if (!hash)
    return;
  try {
    if (hashType === "thumbhash") {
      return createPngDataUri(hash);
    } else {
      if (!ratio && image) {
        const actualWidth = image.width || image.offsetWidth || size;
        const actualHeight = image.height || image.offsetHeight || size;
        ratio = actualWidth / actualHeight;
      }
      return createPngDataUri$1(hash, { ratio, size });
    }
  } catch (error) {
    console.error(`Error generating ${hashType} placeholder:`, error);
  }
}
const resizeElementStore = /* @__PURE__ */ new WeakMap();
function updateSizesAttribute(element, shouldUpdateOnResize = false) {
  const removeResizeObserver = () => {
    const observerInstance = resizeElementStore.get(element);
    if (!observerInstance)
      return;
    observerInstance.disconnect();
    resizeElementStore.delete(element);
  };
  const { sizes } = element.dataset;
  if (sizes !== "auto")
    return removeResizeObserver;
  const width = element instanceof HTMLSourceElement ? element.parentElement?.getElementsByTagName("img")[0]?.offsetWidth : element.offsetWidth;
  if (width)
    element.sizes = `${width}px`;
  if (shouldUpdateOnResize && !resizeElementStore.has(element)) {
    const debounceResize = debounce(() => updateSizesAttribute(element), 500);
    const observerInstance = new ResizeObserver(debounceResize);
    resizeElementStore.set(element, observerInstance);
    observerInstance.observe(element);
  }
  return removeResizeObserver;
}
function updateImageSrc(image) {
  if (image.dataset.src) {
    image.src = image.dataset.src;
    image.removeAttribute("data-src");
  }
}
function updateImageSrcset(image) {
  if (image.dataset.srcset) {
    image.srcset = image.dataset.srcset;
    image.removeAttribute("data-srcset");
  }
}
function updatePictureSources(image) {
  const picture = image.parentElement;
  if (picture?.tagName.toLowerCase() === "picture") {
    [...picture.querySelectorAll("source[data-srcset]")].forEach(updateImageSrcset);
    [...picture.querySelectorAll("source[data-src]")].forEach(updateImageSrc);
  }
}

export { autoSizes, createPlaceholderFromHash, debounce, isCrawler, isLazyLoadingSupported, lazyLoad, loadImage, toElementArray };
